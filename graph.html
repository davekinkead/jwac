<!DOCTYPE html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>JWAC Analysis</title>
  <style>

    body { text-align: center; margin: 0; padding: 0; color: #444;}

    #chart { margin: 1em; }
    #info { position: absolute; bottom: 50px; right: 50px; width: 300px; height: 200px; border: 1px solid #CCC; padding: 1em; box-shadow: 1px 1px 5px rgba(0,0,0,0.5); }

    .node:hover { opacity: 0.5; }
    .link:hover { opacity: 0.325; }
    
    div.tooltip { position: absolute; width: auto; height: auto; padding: 1em; font: 12px sans-serif; background: #EFEFEF; border: 0px; border-radius: 5px; pointer-events: none;
    }
    h4 {margin: 0; padding: 0;}
  </style>
</head>
<body>

<h1>JWAC Graph Analysis</h1>

<div id="chart"></div>
<div id="info">
  <h3>Click to Reset</h3>
  <p>TODO: Allow the user to override gate values for sensitivity analysis.  The downstream gates will turn red if course min/max is exceeded.</p>
</div>
<div id="tooltip"></div>

<script src="http://d3js.org/d3.v3.min.js"></script>
<script>

  var gates = ["NEOC", "ADFA", "Transfer", "Changeover", "JWAC 1", "JWAC 2", "MSB", "JWAC 3 Shore", "JWAC 3 Sea", "Fleet Board", "NOLC1", "JWAC Warfare", "JWAC Simulator", "JWAC Endorsement"];

  var width = screen.width - 100, height = screen.height - 300, nodeWidth = 50, nodePadding = 2, workingData;

  var svg = d3.select('#chart')
    .append('svg')
    .attr('width', width)
    .attr('height', height);

  var tooltip = d3.select("body").append("div")   
    .attr("class", "tooltip")               
    .style("opacity", 0);

  var createBuckets = function(data) {
    var buckets = []

    data.forEach(function(member) {
      member.postings.forEach(function(posting, i) {
        if (buckets[i] == undefined)
          buckets[i] = {};
        if (buckets[i].hasOwnProperty(posting.billet)) {
          buckets[i][posting.billet].push(member.id);
        } else {
          buckets[i][posting.billet] = [member.id];
        }
      });
    });

    return buckets;    
  }

  var createNodes = function(buckets) {
    var gate = 0;

    return [].concat.apply([], buckets.map(function(bucket) {
      var nodes = Object.keys(bucket).map(function(name) {
        return {"name": name, "members": bucket[name], "gate": gate }
      });
      gate++;

      return nodes.sort(function(a, b) {
        if (a.gate == b.gate)
          return b.members.length - a.members.length;
        else
          return a.gate - b.gate;
      });
    }));
  }

  var createLinks = function(nodes) {
    var links = Array.apply(null, Array(nodes.length)).map(function() { return []; });

    nodes.forEach(function(node, index) {
      nodes.forEach(function(n, i) {
        if (node.gate == n.gate - 1 && index !== i)
          node.members.forEach(function(id) {
            if (n.members.indexOf(id) !== -1)
              if (links[index].hasOwnProperty(i))
                links[index][i] += 1;
              else
                links[index][i] = 1;
          });
      });
    });

    var results = []
    links.forEach(function(array, index) {
      array.forEach(function(el, i) {
        results.push ({"source": index, "target": i, "value": el});
      });        
    });
    return results;
  }

  var positionNodesAndLinks = function(nodes, links) {
    var gateTotal = 0;

    var totals = d3.nest()
      .key(function(d) { return d.gate } )
      .entries(nodes)
      .map(function(group) {
      return group.values.map(function(n) {
        return n.members.length;
      }).reduce(function(sum, cur) {
        return sum + cur//.members.length;
      });
    });

    var gateMax = Math.max.apply(null, (totals));
    var factor = height / gateMax;

    nodes.forEach(function(node, index) {
      if (index == 0 || node.gate !== nodes[index-1].gate)
        gateTotal = 0;

      node.x = node.gate * 100;
      node.y = gateTotal * factor;
      node.height = node.members.length * factor - nodePadding;

      gateTotal += node.members.length;
    });

    var offsetLHS = [], offsetRHS = [];
    links.forEach(function(link) {
      var linkL = link.value * (nodes[link.source].height) / nodes[link.source].members.length
      var linkR = link.value * (nodes[link.target].height) / nodes[link.target].members.length

      if (!offsetLHS.hasOwnProperty(link.source))
        offsetLHS[link.source] = 0;
      if (!offsetRHS.hasOwnProperty(link.target))
        offsetRHS[link.target] = 0;

      link.proportion = link.value / nodes[link.source].members.length;
      link.y0 = nodes[link.source].y + offsetLHS[link.source];
      link.y1 = nodes[link.target].y + offsetRHS[link.target];
      link.y2 = nodes[link.target].y + offsetRHS[link.target] + linkR;
      link.y3 = nodes[link.source].y + offsetLHS[link.source] + linkL;
      offsetLHS[link.source] += linkL;
      offsetRHS[link.target] += linkR;

      link.x0 = nodes[link.source].x + nodeWidth + 0;
      link.x1 = nodes[link.target].x - 0;
    });
  }

  function renderChart(data) {
  
    var colour = function(target) {
      if (gates.indexOf(target) !== -1) {
        return '#08306B';
      } else {
        return '#666';
      }
    }  
  
    var linkPoints = function(d) {
      return 'M'+ d.x0 +' '+ d.y0 
        +' L'+ d.x1 +' '+ d.y1 
        +' L'+ d.x1 +' '+ d.y2 
        +' L'+ d.x0 +' '+ d.y3
        +' Z';
    }

    workingData = data;
    var buckets = createBuckets(workingData);
    var nodeData = createNodes(buckets);
    var linkData = createLinks(nodeData);

    positionNodesAndLinks(nodeData, linkData);

    var nodes = svg.selectAll('.node')
      .data(nodeData);

    nodes.enter()
      .append('circle')
      .attr('class', 'node')
      .attr('cx', function(d) { return d.x })
      .attr('cy', function(d) { return d.y })
      .attr('r', function(d) { return d.members.length })
      .attr('opacity', 0.375)
      .on('mouseover', function(d) {
        tooltip.transition()        
          .duration(200)      
          .style("opacity", .9);      
        tooltip.html('<h4>'+d.name +"</h4><br/>"+ d.members.length + " JOUTs")  
          .style("left", (d3.event.pageX) + "px")     
          .style("top", (d3.event.pageY - 28) + "px");    
      })
      .on('mouseout', function(d) {
        tooltip.transition()
          .duration(200)
          .style("opacity", 0);
      })
      .on('dblclick', function(d) { 
        workingData = workingData.filter(function(datum) {
          return (d.members.indexOf(datum.id) !== -1);
        });
        renderChart(workingData);
      })
      .append('title');

    nodes.transition()
      .attr('cx', function(d) { return d.x })
      .attr('cy', function(d) { return d.y })
      .attr('r', function(d) { return d.members.length })
      .attr('fill', function(d) { return colour(d.name) })
    
    nodes.exit()
      .remove();

    var links = svg.selectAll('.link')
      .data(linkData);

    links.enter()
      .append('path')
      .attr('d', linkPoints)
      .attr('opacity', 0.25)
      .attr('class', 'link')
      .on('mouseover', function(d) {
        tooltip.transition()        
          .duration(200)      
          .style("opacity", .9);      
        tooltip.html('<h4>'+ nodeData[d.source].name +' -> '+ nodeData[d.target].name +'</h4><br/>'+ d.value +' JOUTs ('+ d.proportion.toFixed(2) * 100 +'%)')  
          .style("left", (d3.event.pageX + 50) + "px")     
          .style("top", (d3.event.pageY - 50) + "px");    
      })
      .on('mouseout', function(d) {
        tooltip.transition()
          .duration(200)
          .style("opacity", 0);
      });

    links.transition()
      .attr('d', linkPoints)
      .attr('fill', function(d) { return colour(nodeData[d.target].name) });
     
    links.exit().remove();
  }

  d3.json('data.json', function(json) {

    renderChart(json);
    d3.select('#info').on('dblclick', function() {renderChart(json)} );
 
  });

</script>

</body>
</html>
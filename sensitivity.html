<!DOCTYPE html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=8;FF=3;OtherUA=4" />
  <title>JWAC Sensitivity Analysis</title>
  <style>

    body { text-align: center; margin: 0; padding: 0; }

    #chart { margin: 1em; }
    #info { position: absolute; bottom: 50px; right: 50px; width: 300px; height: 200px; border: 1px solid #CCC; padding: 1em; box-shadow: 1px 1px 5px rgba(0,0,0,0.5); }

    .node:hover { opacity: 0.5; }
    .link:hover { opacity: 0.325; }
    
  </style>
</head>
<body>

<h1>JWAC Sensitivity Analysis</h1>

<div id="chart"></div>
<div id="info">
  <h3>Click to Edit</h3>
  <p>TODO: Allow the user to override gate values for sensitivity analysis.  The downstream gates will turn red if course min/max is exceeded.</p>
</div>

<script src="http://d3js.org/d3.v3.min.js"></script>
<script src="sankey.js"></script>
<script>

  var gates = ["NEOC", "ADFA", "Transfer", "Changeover", "JWAC 1", "JWAC 2", "MSB", "JWAC 3 Shore", "JWAC 3 Sea", "Fleet Board", "NOLC1", "JWAC Warfare", "JWAC Simulator", "JWAC Endorsement"];

  var width = screen.width - 100, height = screen.height - 300, nodeWidth = 50, nodePadding = 2;

  var svg = d3.select('#chart')
    .append('svg')
    .attr('width', width)
    .attr('height', height);

  var sumNodes = function(nodes) {
    return nodes.map(function(node) { 
        return node.members.length;
      }).reduce(function(prev, curr) { 
        return prev + curr;
      }); 
  }

  var createNodes = function(buckets) {
    var gate = 0;

    return [].concat.apply([], buckets.map(function(bucket) {
      var nodes = Object.keys(bucket).map(function(name) {
        return {"name": name, "members": bucket[name], "gate": gate }
      });
      gate++;
      return positionNodesVertically(nodes);
    }));
  }

  var positionNodesVertically = function(nodes) {
    var denominator = sumNodes(nodes), pos = 0;
    denominator = 100;

    return nodes.sort(function(a, b) { 
        return b.members.length - a.members.length;
      }).map(function(node) {
        node.y = pos / denominator * height + nodePadding;
        node.height = node.members.length / denominator * height - nodePadding;
        pos += node.members.length;
        return node;
      });
  }

  var createBuckets = function(data) {
    var buckets = []

    data.forEach(function(member) {
      member.postings.forEach(function(posting, i) {
        if (buckets[i] == undefined)
          buckets[i] = {};
        if (buckets[i].hasOwnProperty(posting)) {
          buckets[i][posting].push(member.id);
        } else {
          buckets[i][posting] = [member.id];
        }
      });
    });

    return buckets;    
  }

  var createLinks = function(nodes) {
    var links = Array.apply(null, Array(nodes.length)).map(function() { return []; });

    nodes.forEach(function(node, index) {
      nodes.forEach(function(n, i) {
        if (node.gate == n.gate - 1 && index !== i)
          node.members.forEach(function(id) {
            if (n.members.indexOf(id) !== -1)
              if (links[index].hasOwnProperty(i))
                links[index][i] += 1;
              else
                links[index][i] = 1;
          });
      });
    });

    var results = []
    links.forEach(function(array, index) {
      array.forEach(function(el, i) {
        results.push ({"source": index, "target": i, "value": el});
      });        
    });
    return results;
  }

  var positionNodesAndLinks = function(nodes, links) {
    nodes.forEach(function(node) {
      node.x = node.gate * 125;
    });

    var offsetLHS = [], offsetRHS = [];
    links.forEach(function(link) {
      var linkL = link.value * (nodes[link.source].height) / nodes[link.source].members.length
      var linkR = link.value * (nodes[link.target].height) / nodes[link.target].members.length

      if (!offsetLHS.hasOwnProperty(link.source))
        offsetLHS[link.source] = 0;
      if (!offsetRHS.hasOwnProperty(link.target))
        offsetRHS[link.target] = 0;

      link.proportion = link.value / nodes[link.source].members.length;
      link.y0 = nodes[link.source].y + offsetLHS[link.source];
      link.y1 = nodes[link.target].y + offsetRHS[link.target];
      link.y2 = nodes[link.target].y + offsetRHS[link.target] + linkR;
      link.y3 = nodes[link.source].y + offsetLHS[link.source] + linkL;
      offsetLHS[link.source] += linkL;
      offsetRHS[link.target] += linkR;

      link.x0 = nodes[link.source].x + nodeWidth + 0;
      link.x1 = nodes[link.target].x - 0;
    });
  }

  var colour = function(target) {
    if (gates.indexOf(target) !== -1) {
      return '#2E86D1';
    } else {
      return '#666';
    }
  }

  d3.json('data.json', function(json) {

    var buckets = createBuckets(json)
    var nodes = createNodes(buckets);
    var links = createLinks(nodes)
    positionNodesAndLinks(nodes, links);


    var linkPoints = function(d) {
      return 'M'+ d.x0 +' '+ d.y0 
        +' L'+ d.x1 +' '+ d.y1 
        +' L'+ d.x1 +' '+ d.y2 
        +' L'+ d.x0 +' '+ d.y3
        +' Z';
    }

    svg.append('g')
      .selectAll('.node')
      .data(nodes)
      .enter()
      .append('rect')
      .attr('x', function(d) { return d.x })
      .attr('y', function(d) { return d.y })
      .attr('width', nodeWidth) //function(d) { return nodeWidth(node); })
      .attr('height', function(d) { return d.height })
      .attr('fill', function(d) { return colour(d.name) })
      .attr('opacity', 0.375)
      .attr('class', 'node')
      .append('title')
      .text(function(d) { return d.name + '\n ' + d.members.length }); 

    svg.append('g')
      .selectAll('.link')
      .data(links)
      .enter()
      .append('path')
      .attr('d', linkPoints)
      .attr('fill', function(d) { return colour(nodes[d.target].name) })
      .attr('opacity', 0.25)
      .attr('class', 'link')
      .append('title')
      .text(function(d) { return nodes[d.source].name +' -> '+ nodes[d.target].name +'\n'+ d.value +' ('+ d.proportion.toFixed(2) * 100 +'%)'}); 
  
  });

</script>

</body>
</html>